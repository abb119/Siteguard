<!DOCTYPE html>
<html>

<head>
    <title>SiteGuard Real-Time Video Detection</title>
    <style>
        body {
            font-family: Arial;
            max-width: 1200px;
            margin: 20px auto;
            background: #1e1e1e;
            color: #fff;
        }

        h1 {
            text-align: center;
        }

        #container {
            position: relative;
            width: 640px;
            height: 480px;
            margin: 20px auto;
            border: 2px solid #333;
            background: #000;
        }

        video,
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .controls {
            text-align: center;
            margin: 20px;
            padding: 20px;
            background: #2d2d2d;
            border-radius: 8px;
        }

        button {
            padding: 10px 20px;
            margin: 5px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            transition: opacity 0.2s;
        }

        button:hover {
            opacity: 0.8;
        }

        .btn-webcam {
            background-color: #2196F3;
            color: white;
        }

        .btn-start {
            background-color: #4CAF50;
            color: white;
        }

        .btn-stop {
            background-color: #f44336;
            color: white;
        }

        #stats {
            text-align: center;
            font-size: 14px;
            margin-top: 10px;
            font-family: monospace;
        }

        .legend {
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }

        .legend span {
            padding: 5px 10px;
            margin: 0 10px;
            border-radius: 3px;
        }

        .compliant {
            background: rgba(0, 255, 0, 0.2);
            color: #4CAF50;
            border: 1px solid #4CAF50;
        }

        .violation {
            background: rgba(255, 0, 0, 0.2);
            color: #f44336;
            border: 1px solid #f44336;
        }
    </style>
</head>

<body>
    <h1>üë∑ SiteGuard Real-Time Detection</h1>

    <div class="legend">
        <span class="compliant">‚úì Compliant (Helmet + Vest)</span>
        <span class="violation">‚ö† Violation (Missing PPE)</span>
    </div>

    <div class="controls">
        <h3>1. Select Source</h3>
        <button onclick="useWebcam()" class="btn-webcam">üì∑ Use Webcam</button>
        <span style="margin: 0 10px;">OR</span>
        <input type="file" id="videoFile" accept="video/*">

        <br><br>
        <h3>2. Control Detection</h3>
        <button onclick="startDetection()" class="btn-start">‚ñ∂ Start Detection</button>
        <button onclick="stopDetection()" class="btn-stop">‚èπ Stop</button>
    </div>

    <div id="container">
        <video id="video" playsinline></video>
        <canvas id="canvas" width="640" height="480"></canvas>
    </div>

    <div id="stats">FPS: 0 | Detections: 0 | Violations: 0</div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const stats = document.getElementById('stats');

        let ws = null;
        let detecting = false;
        let fps = 0;
        let lastTime = Date.now();
        let latestDetections = [];
        let animationFrameId = null;

        // Handle video file selection
        document.getElementById('videoFile').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                video.src = URL.createObjectURL(file);
                video.controls = true;
            }
        });

        // Handle Webcam
        async function useWebcam() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                video.play();
                video.controls = false;
                console.log("Webcam started");
            } catch (err) {
                console.error("Error accessing webcam:", err);
                alert("Could not access webcam. Please ensure you have granted camera permissions.");
            }
        }

        function startDetection() {
            if (detecting) return;

            // Check if video source is ready
            if (!video.srcObject && !video.src) {
                alert("Please select a video source (Webcam or File) first!");
                return;
            }

            detecting = true;
            latestDetections = [];

            // Connect to WebSocket
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.hostname}:8000/ws/video-stream`;
            console.log("Connecting to:", wsUrl);

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                if (video.paused) video.play();
                requestAnimationFrame(renderLoop);
                setTimeout(sendFrame, 100); // Start sending frames
            };

            ws.onmessage = (event) => {
                try {
                    const data = JSON.parse(event.data);
                    latestDetections = data.detections || [];

                    // Calculate FPS
                    const now = Date.now();
                    fps = Math.round(1000 / (now - lastTime));
                    lastTime = now;

                    // Update stats
                    const violations = latestDetections.filter(d => d.is_compliant === false).length;
                    stats.textContent = `FPS: ${fps} | Detections: ${latestDetections.length} | Violations: ${violations}`;
                } catch (e) {
                    console.error("Error parsing message:", e);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                stopDetection();
                alert("WebSocket connection error. Is the API running?");
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                stopDetection();
            };
        }

        function renderLoop() {
            if (!detecting) return;

            // Draw video frame to canvas if needed (optional, video element shows it too)
            // But we need to clear canvas for drawing boxes
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw detections
            drawDetections(latestDetections);

            animationFrameId = requestAnimationFrame(renderLoop);
        }

        function sendFrame() {
            if (!detecting || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }

            if (video.paused || video.ended) {
                setTimeout(sendFrame, 100);
                return;
            }

            // Create a small temp canvas to resize frame before sending (optimizes bandwidth)
            const tempCanvas = document.createElement('canvas');
            const scale = 0.5; // Send smaller image for speed
            tempCanvas.width = 640 * scale;
            tempCanvas.height = 480 * scale;

            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(video, 0, 0, tempCanvas.width, tempCanvas.height);

            // Convert to base64 jpeg
            const dataURL = tempCanvas.toDataURL('image/jpeg', 0.6);

            // Send
            ws.send(dataURL);

            // Schedule next frame
            setTimeout(sendFrame, 100); // ~10 FPS sending rate
        }

        function drawDetections(detections) {
            if (!detections || detections.length === 0) return;

            ctx.lineWidth = 3;
            ctx.font = 'bold 16px Arial';

            detections.forEach(det => {
                // Scale coordinates if we resized the input (not needed if we send/receive relative coords, 
                // but YOLO returns absolute for the input size. Assuming input was 640x480)
                // If we sent scaled image, we might need to scale back. 
                // Let's assume the model returns coords relative to the image sent.
                // Since we sent 0.5 scale, we need to multiply by 2 to draw on full canvas.

                const scaleFactor = 1 / 0.5;

                let [x1, y1, x2, y2] = det.box;

                // Adjust for scaling
                x1 *= scaleFactor;
                y1 *= scaleFactor;
                x2 *= scaleFactor;
                y2 *= scaleFactor;

                const isCompliant = det.is_compliant !== false;
                const color = isCompliant ? '#00ff00' : '#ff0000';
                const fillColor = isCompliant ? 'rgba(0, 255, 0, 0.1)' : 'rgba(255, 0, 0, 0.2)';

                const sx1 = x1;
                const sy1 = y1;
                const sw = x2 - x1;
                const sh = y2 - y1;

                // Draw Box
                ctx.strokeStyle = color;
                ctx.strokeRect(sx1, sy1, sw, sh);

                // Draw Fill
                ctx.fillStyle = fillColor;
                ctx.fillRect(sx1, sy1, sw, sh);

                // Draw Label
                const label = `${det.class_name} ${(det.confidence * 100).toFixed(0)}%`;
                const labelY = sy1 > 20 ? sy1 - 5 : sy1 + 20;

                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                const textMetrics = ctx.measureText(label);
                ctx.fillRect(sx1, labelY - 18, textMetrics.width + 10, 22);

                ctx.fillStyle = color;
                ctx.fillText(label, sx1 + 5, labelY);
            });
        }

        function stopDetection() {
            detecting = false;
            if (ws) ws.close();
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            video.pause();
            latestDetections = [];
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            stats.textContent = "Stopped";
        }
    </script>
</body>

</html>